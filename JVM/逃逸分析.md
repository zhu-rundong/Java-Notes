# 逃逸分析

## 逃逸分析

逃逸分析（Escape Analysis）是 JVM 的另一个重要的优化技术，但它并不是直接优化代码的手段，而是通过动态分析对象的作用域，为其他优化措施，如栈上分配、标量替换和同步消除提供依据。

在 JVM 的即时编译语境下，逃逸分析将判断**新建的对象**是否逃逸。当一个对象在方法里面被定义后，发生逃逸行为的有两种：

1. **方法逃逸：**它可能被外部方法所引用，例如作为调用参数传递到其他方法中。
2. **线程逃逸：**它被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量。

从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。

**判断是否逃逸有什么用呢？**

用处很大。只要我们判断出了该对象没有逃逸出方法或线程，就可以采用更加优化的方法来管理该对象。例如：同步消除、标量替换和栈上分配。

## 基于逃逸分析的优化

### 同步消除

线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量的同步锁也可以安全地消除掉。通过 JVM 参数`-XX:+EliminateLocks`可以开启同步消除。

实际上，传统编译器仅需证明锁对象不逃逸出线程，便可以进行同步消除。由于 JVM 即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。

不过，基于逃逸分析的同步消除实际上并不多见。一般来说，开发人员不会直接对方法中新构造的对象进行加锁。事实上，逃逸分析的结果更多被用于将新建对象操作转换成栈上分配或者标量替换。

### 栈上分配

在 Java 语言里，对象的内存通常都是在堆中申请的。对象不再被访问以后，会由垃圾收集器回收。下面来看一段代码：

~~~java
public int escapeTest(int age){
    Person p = new Person(age);
    return p.ageSegment();
}

public class Person{
    private int age;
    private float weight;

    public Person(int age){
       this.age = age;     
    }

    //返回年龄段
    final public int ageSegment(){
        if (age < 20)
            return 1;
        else
            return 2;        
    } 

    get、set...
}
~~~

在上述代码种，Person 对象的生命周期跟 `escapeTest()` 方法的生命周期是一样的。在退出方法后，就不再会有别的程序来访问该对象。

换句话说，这个对象跟一个 int 类型的本地变量没啥区别。那么也就意味着，我们其实可以在栈里给这个对象申请内存就行了。

如果逃逸分析能够证明某些新建的对象不逃逸，那么 JVM 完全可以将其分配至栈上，并且在 new 语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。

**栈上分配可以支持方法逃逸，但不能支持线程逃逸。**

不过，由于实现起来需要更改大量假设了“对象只能堆分配”的代码，因此 HotSpot 虚拟机并没有采用栈上分配，而是使用了标量替换这么一项技术。

### 标量替换

若一个数据已经无法再分解成更小的数据来表示了，JVM 中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为**标量**。

把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为**标量替换**。

在上述示例程序，只用到了 Person 对象的 age 成员变量，而 weight 根本没有涉及。所以，我们在栈上申请内存的时候，根本没有必要为 weight 保留内存。

通过标量替换的技术，我们可以根本不生成对象实例，而是把要用到的对象的成员变量，作为普通的本地变量（也就是标量）来管理。这么做编译器就可以尽量把标量放到寄存器里去，连栈都不用，这样就避免了内存访问所带来的性能消耗。

通过 JVM 参数`-XX:+EliminateAllocations`可以开启标量替换， `-XX:+PrintEliminateAllocations`查看标量替换情况。

## 部分逃逸分析

C2 的逃逸分析都是静态分析，也就是基于对代码所做的分析。对于一个对象来说，只要存在任何一个控制流，使得它逃逸了，那么编译器就会把它标注为是逃逸对象，也就不能做优化了。但是，还会出现一种情况，就是有可能这个分支的执行频率特别少，大部分情况下该对象都是不逃逸的。

所以，Graal 则引入了一个与控制流有关的逃逸分析，名为部分逃逸分析（partial escape analysis）。它解决了所新建的实例仅在部分程序路径中逃逸的情况。

在下面这段代码中，新建实例只会在进入 if-then 分支时逃逸。（对 hashCode 方法的调用是一个 HotSpot intrinsic，将被替换为一个无法内联的本地方法调用。）

~~~java
public static void bar(boolean cond) {
  Object foo = new Object();
  if (cond) {
    foo.hashCode();
  }
}
// 可以手工优化为：
public static void bar(boolean cond) {
  if (cond) {
    Object foo = new Object();
    foo.hashCode();
  }
}
~~~

假设 if 语句的条件成立的可能性只有 1%，那么在 99% 的情况下，程序没有必要新建对象。其手工优化的版本正是部分逃逸分析想要自动达到的成果。

部分逃逸分析将根据控制流信息，判断出新建对象仅在部分分支中逃逸，并且将对象的新建操作推延至对象逃逸的分支中。这将使得原本因对象逃逸而无法避免的新建对象操作，不再出现在只执行 if-else 分支的程序路径之中。

Graal 与 C2 所使用的逃逸分析相比，所使用的部分逃逸分析能够优化更多的情况，不过它编译时间也更长一些。

## 参考资料

1. [《深入拆解Java虚拟机》郑雨迪](https://time.geekbang.org/column/intro/108)
