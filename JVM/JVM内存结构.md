# JVM内存结构

## JVM 运行时内存结构

JVM 在执行Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

根据《Java虚拟机规范》的规定，JVM 所管理的内存将会包括以下几个运行时数据区域，如下图所示：

   ![image-20210407213212443](assets/20210412201647-1672645624777-71.png)

### PC寄存器

又叫程序计数器，线程私有，可以看作是当前线程所执行的字节码的行号指示器，指向下一条需要执行的字节码指令。

如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地 址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何 `OutOfMemoryError` 情况的区域。

### Java 方法栈

线程私有，它的生命周期与线程相同。每个方法被执行的时候，JVM 都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚 拟机所允许的深度，将抛出`StackOverflowError` 异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出 `OutOfMemoryError` 异常。

### 本地方法栈

本地方法栈（Native Method Stacks）与 Java 方法栈所发挥的作用是非常相似的，其区别只是Java 方法栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

与 Java 方法栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出 `StackOverflowError` 和 `OutOfMemoryError` 异常。

### 堆

线程共享，存放对象实例以及数组。

堆是垃圾收集器管理的内存区域，因此也被称作**GC堆**（Garbage Collected Heap）。由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以堆中经常会出现`新生代`、`老年代`、`永久代`、`Eden空间`等，接下来会具体分析。

堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的JVM 都是按照可扩展来实现的（通过参数`-Xmx`和`-Xms`设定）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出 `OutOfMemoryError` 异常。

### 方法区

线程共享，存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作`非堆（Non-Heap）`，目的是与堆区分开来。

此外，方法区中还包括运行时常量池（Runtime Constant Pool）、Compressed Class Space、Code Cache。

**运行时常量池（Runtime Constant Pool）：**用于存放类或接口编译期生成的各种字面量（数值字面量、字符串字面量）与符号（方法或字段）引用，JVM 就会在运行时常量池中搜索其具体的内存地址。

运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，在运行期间也可以将新的常量放入池中。

**Compressed Class Space：**存放 class 信息的，和 Metaspace 有交叉。

**Code Cache：**存放 JIT 编译器编译后的本地机器代码。

### 堆内存和栈内存

简单的来说，JVM 内存还可以笼统地划分为堆内存（Heap）和栈内存（Stack）。

![image-20210615212314947](assets/20210615212315.png)

## JVM 内存整体结构

![image-20210615214316930](assets/20210615214317.png)

每启动一个线程，JVM 就会在栈空间栈分配对应的线程栈, 比如 1MB 的空间（-Xss1m）。线程栈也叫做 Java 方法栈。 如果使用了JNI 方法，则会分配一个单独的本地方法栈（Native Stack）。

线程执行过程中，一般会有多个方法组成调用栈（Stack Trace）, 比如 A 调用 B，B 调用 C。。。每执行到一个方法，就会创建对应的栈帧（Frame）。

## JVM 栈内存结构

![image-20210615215142509](assets/20210615215142.png)

栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后基本上就能确定。比如返回值需要有一个空间存放，每个局部变量都需要对应的地址空间，此外还有给指令使用的操作数栈，以及 class 指针（标识这个栈帧对应的是哪个类的方法，指向非堆里面的 Class 对象）。

### 局部变量表

存储基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型）和`returnAddress` 。

其中的存储空间以局部变量槽（Slot）来表示，一个变量槽可以存放一个 32 位以内的数据类型。但是，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小。它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化，保证了即使在64位虚拟机中使用了 64 位的物理内存空间去实现一个变量槽，虚拟机仍要使用对齐和补白的手段变量槽在外观上看起来与 32 位虚拟机中的一致。

在 32 位虚拟机中，其中 64 位长度的 long 和 double 类型的数据虚拟机会以高位对齐方式为其分配两个连续的 Slot 空间，其余的数据类型只占用一个。

对于 reference 类型，它表示对一个对象实例的引用，一般来说，虚拟机能通过这个引用做到以下两点：

1. 查找到对象在 Java 堆中的数据存放的起始地址或索引
2. 查找到对象所属数据类型在方法区中的存储的类型信息

为了尽可能节省栈帧耗用的内存空间，变量槽（Slot）是可以重用的。如果当前字节码 PC计数器的值已经超出了某个变量的作用域（执行完毕），那这个变量对应的变量槽就可以交给其他变量来重用。

但是，这也会影响到系统的垃圾收集行为。比如方法的某个变量占用了较多的 Slot，执行完该变量的作用域后没有对 Slot 清空或者设置变量 null 值，垃圾回收器便不能及时的回收该内存。

局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小（变量槽的数量）。

### 操作数栈

操作数栈（Operand Stack）是一个后入先出（Last In First Out，LIFO）栈，和局部变量表一样，在编译时期就已经确定了最大容量，主要用来存放计算的操作数以及返回结果。

操作数栈的每一个元素可以是任意Java数据类型，包括 long 和 double 在内的。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如：在做算术运算的时候是通过将运算涉及的操作数栈压入栈顶后调用运算指令来进行的；在调用其他方法的时候是通过操作数栈来进行方法参数的传递。

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。

在类加载阶段或者第一次使用的时候将常量池中的符号转化为直接引用，这种转化被称为静态解析。 另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

### 方法返回地址

当一个方法开始执行后，只有两种方式退出这个方法：

1. 执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为`正常调用完成（Normal Method Invocation Completion）`。
2. 在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理，就会导致方法退出。

无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。

一般来说，方法正常退出时，主调方法的 PC 计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。

## JVM 堆内存结构

![image-20210620100920431](assets/20210620100927.png)

堆内存是所有线程共用的内存空间，JVM 将 Heap 内存分为年轻代（Young generation）和 老年代（Old generation）两部分。

堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 `–Xms`、`-Xmx` 来指定。默认情况下，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1 : 2 ( 可以通过参数 `–XX:NewRatio` 来设定 )

### 年轻代

主要用来存放新生的对象。大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

年轻代划分为 3 个内存池，新生代（Eden space）和存活区（Survivor space）, 在大部分 GC 算法中有 2 个存活区（S0, S1），S0 和 S1 总有一个是空的。默认情况下，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 `–XX:SurvivorRatio` 来设定 )。

### 老年代

主要存放应用程序声明周期长的内存对象。

长期存活的对象将进入老年代。HotSpot 虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中，对象在 Eden 区里如果经过第一次 Minor GC后仍然存活，并且能被 Survivor 容纳的话，该对象会被移动到 Survivor 空间中，并且将其对象年龄设为1岁。此后，对象在 Survivor 区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程 度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数`-XX：MaxTenuringThreshold`设置。

HotSpot 虚拟机并不是永远要求对象的年龄必须达到`- XX：MaxTenuringThreshold`才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到`-XX： MaxTenuringThreshold`中要求的年龄。

此外，大对象直接进入老年代。大对象就是指需要大量连续内存空间的 Java 对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。

HotSpot 虚拟机提供了`-XX：PretenureSizeThreshold` 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在  Eden 区及两个 Survivor 区之间来回复制，产生大量的内存复制操作。

## JVM 内存参数关系

![image-20210620145947529](assets/20210620145947.png)
