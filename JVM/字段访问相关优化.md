# 字段访问相关优化

## 前言

之前的 ["逃逸分析"](./逃逸分析.md) 文章介绍了基于逃逸分析的优化方式锁消除、栈上分配以及标量替换等内容。虽然在一些情况下，逃逸分析以及基于逃逸分析的优化已经十分高效了。但是，在现实中，Java 程序中的对象或许本身便是逃逸的，或许因为方法内联不够彻底而被即时编译器当成是逃逸的。这两种情况都将导致即时编译器无法进行标量替换。这时候，针对对象字段访问的优化也变得格外重要起来。

~~~java
static int bar(Foo o, int x) {
  o.a = x;
  return o.a;
}
~~~

在上面这段代码中，对象 o 是传入参数，不属于逃逸分析的范围（JVM 中的逃逸分析针对的是新建对象）。该方法会将所传入的 int 型参数 x 的值存储至实例字段 Foo.a 中，然后再读取并返回同一字段的值。

这段代码将涉及两次内存访问操作：存储以及读取实例字段 Foo.a。由于这段代码较为简单，因此它极大可能被编译为寄存器之间的移动指令（即将输入参数 x 的值移至寄存器 eax 中）。这与原本的内存访问指令相比，显然要高效得多。

~~~java
static int bar(Foo o, int x) {
  o.a = x;
  return x;
}
~~~

那么即时编译器是否能够作出类似的自动优化呢？答案是可以的。

## 字段读取优化

即时编译器会优化实例字段以及静态字段访问，以减少总的内存访问数目。具体来说，它将沿着控制流，缓存各个字段存储节点将要存储的值，或者字段读取节点所得到的值。

当即时编译器遇到对同一字段的读取节点时，如果缓存值还没有失效，那么它会将读取节点替换为该缓存值。

当即时编译器遇到对同一字段的存储节点时，它会更新所缓存的值。当即时编译器遇到可能更新字段的节点时，如方法调用节点（在即时编译器看来，方法调用会执行未知代码），或者内存屏障节点（其他线程可能异步更新了字段），那么它会采取保守的策略，舍弃所有缓存值。

~~~java
static int bar(Foo o, int x) {
  int y = o.a + x;
  return o.a + y;
}
~~~

例如：上面这段代码中，实例字段 Foo.a 将被读取两次。即时编译器会将第一次读取的值缓存起来，并且替换第二次字段读取操作，以节省一次内存访问。

~~~java
static int bar(Foo o, int x) {
  int t = o.a;
  int y = t + x;
  return t + y;
}
~~~

如果字段读取节点被替换成一个常量，那么它将进一步触发更多优化。

~~~java
static int bar(Foo o, int x) {
  o.a = 1;
  if (o.a >= 0)
    return x;
  else
    return -x;
}
~~~

例如在上面这段代码中，实例字段 Foo.a 会被赋值为 1。接下来的 if 语句将判断同一实例字段是否不小于 0。经过字段读取优化之后，>= 节点的两个输入参数分别为常数 1 和 0，因此可以直接替换为具体结果 true。如此一来，else 分支将变成不可达代码，可以直接删除，其优化结果如下所示。

~~~java
static int bar(Foo o, int x) {
  o.a = 1;
  return x;
}
~~~

再看一个例子

~~~java
class Foo {
  boolean a;
  void bar() {
    a = true;
    while (a) {}
  }
  void whatever() { a = false; }
}
~~~

同样，即时编译器会将 while 循环中读取实例字段a的操作直接替换为常量true，即下面代码所示的死循环。

~~~java
void bar() {
    a = true;
    while (true) {}
  }
// 生成的机器码将陷入这一死循环中
0x066b: mov    r11,QWORD PTR [r15+0x70] // 安全点测试
0x066f: test   DWORD PTR [r11],eax      // 安全点测试
0x0672: jmp    0x066b                   // while (true)
~~~

我们知道通过 volatile 关键字标记实例字段 a，以此强制对它的读取。实际上，即时编译器将在 volatile 字段访问前后插入内存屏障节点。这些内存屏障节点会阻止即时编译器将屏障之前所缓存的值用于屏障之后的读取节点之上。

在上述例子，尽管 volatile 字段读取操作前后的内存屏障是 no-op，在即时编译过程中的屏障节点，还是会阻止即时编译器的字段读取优化，强制在循环中使用内存读取指令访问实例字段Foo.a的最新值。

同理，加锁、解锁操作也同样会阻止即时编译器的字段读取优化。

## 字段存储优化

除了字段读取优化之外，即时编译器还会消除冗余的存储节点。如果一个字段先后被存储了两次，而且这两次存储之间没有对第一次存储内容的读取，那么即时编译器可以将第一个字段存储给消除掉。

~~~java
class Foo {
  int a = 0;
  void bar() {
    a = 1;
    a = 2;
  }
}
~~~

上面这段代码中的 bar 方法先后存储了两次Foo.a实例字段。由于第一次存储之后没有读取Foo.a的值，因此，即时编译器会将其看成冗余存储，并将之消除掉，生成如下代码：

~~~java
 void bar() {
    a = 2;
  }
~~~

如果在这两个字段存储操作之间读取该字段，即时编译器还是有可能在字段读取优化的帮助下，将第一个存储操作当成冗余存储给消除掉。

~~~java

class Foo {
  int a = 0;
  void bar() {
    a = 1;
    int t = a;
    a = t + 2;
  }
}
// 优化为
class Foo {
  int a = 0;
  void bar() {
    a = 1;
    int t = 1;
    a = t + 2;
  }
}
// 进一步优化为
class Foo {
  int a = 0;
  void bar() {
    a = 3;
  }
}
~~~

当然，如果所存储的字段被标记为 volatile，那么即时编译器也不能将冗余的存储操作消除掉。

## 死代码消除

除了字段存储优化之外，局部变量的死存储（dead store）同样也涉及了冗余存储。这是死代码消除（dead code elimination）的一种。不过，由于 Sea-of-Nodes IR 的特性，死存储的优化无须额外代价。

**Sea-of-Nodes IR：** C2 编译器中的 Ideal Graph 采用的是一种名为 Sea-of-Nodes 中间表达形式，同样也是 SSA（Static Single Assignment，静态单赋值，每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用）形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。

~~~java
int bar(int x, int y) {
  int t = x*y;
  t = x+y;
  return t;
}
~~~

上面这段代码涉及两个存储局部变量操作。当即时编译器将其转换为 Sea-of-Nodes IR 之后，没有节点依赖于 t 的第一个值x*y。因此，该乘法运算将被消除，其结果如下所示：

~~~java
int bar(int x, int y) {
  return x+y;
}
~~~

死存储还有一种变体，即在部分程序路径上有冗余存储。

~~~java
int bar(boolean f, int x, int y) {
  int t = x*y;
  if (f)
    t = x+y;
  return t;
}
~~~

上面这段代码中，如果所传入的 boolean 类型的参数f是 true，那么在程序执行路径上将先后进行两次对局部变量 t 的存储。同样，经过 Sea-of-Nodes IR 转换之后，返回节点所依赖的值是一个 phi 节点，将根据程序路径选择 x+y 或者 x*y。也就是说，当f为 true 的程序路径上的乘法运算会被消除，其结果如下所示：

~~~java
int bar(boolean f, int x, int y) {
  int t;
  if (f)
    t = x+y;
  else
    t = x*y;
  return t;
}
~~~

另一种死代码消除则是不可达分支消除（任何程序路径都不可到达的分支）。

在即时编译过程中，经常因为方法内联、常量传播以及基于 profile 的优化等，生成许多不可达分支。通过消除不可达分支，即时编译器可以精简数据流，并且减少编译时间以及最终生成机器码的大小。

~~~java
int bar(int x) {
  if (false)
    return x;
  else
    return -x;
}
~~~

在上面的代码中，if 语句将一直跳转至 else 分支之中。因此，另一不可达分支可以直接消除掉，形成下面的代码：

~~~java
int bar(int x) {
  return -x;
}
~~~

## 参考资料

1. [《深入拆解Java虚拟机》郑雨迪
