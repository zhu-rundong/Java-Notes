# JVM是怎么实现synchronized的

## synchronized 的实现

synchronized 是 Java 中的关键字，我们可以用它来对程序进行加锁，以达到线程同步的目的。

Java 中的每一个对象都可以作为锁，主要表现形式为：

1. 对于同步代码块，锁是 synchronized 括号里配置的对象。
2. 对于实例方法，锁是当前实例对象。
3. 对于静态方法，锁是所在类的 Class 对象。

普通同步方法用的都是同一把锁：实例对象本身，也就是new出来的具体实例对象本身，如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放后才能获取锁。

静态同步方法用的也是同一把锁：类对象本身，一个静态同步方法获取锁后，其他的静态同步方法也都必须等待该方法释放锁后才能获取锁。

实例对象和类对象，这两把锁是不同的对象，所以静态同步方法和普通同步方法之间不会存在竞态条件。

JVM 中 Synchronization 是基于进入和退出管程（Monitor，也可将它称为 “锁”）实现的， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。

### Java 对象头

在 JVM 中，对象在堆内存中的存储布局分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。而 synchronized 用的锁是存在对象头里的。

对象头部分包括了两类信息：

1. 存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为 `Mark Word`。
2. 存储类型指针，即对象指向它的类型元数据的指针，JVM 通过这个指针来确定该对象是哪个类的实例。

由于对象头中存储的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，`Mark Word`被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。如下图所示，在不同锁的状态下，对象头所对应不同的存储结构。

![image-20210718102611456](assets/20210718102618.png)

### 同步代码块

~~~java
 public void foo(Object lock) {
        synchronized (lock) {
            lock.hashCode();
        }
    }
//---将上面的Java代码通过 javap 命令编译为下面的字节码---
public void foo(java.lang.Object);
    descriptor: (Ljava/lang/Object;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=2
         0: aload_1
         1: dup
         2: astore_2
         3: monitorenter
         4: aload_1
         5: invokevirtual #2                  // Method java/lang/Object.hashCode:()I
         8: pop
         9: aload_2
        10: monitorexit
        11: goto          19
        14: astore_3
        15: aload_2
        16: monitorexit
        17: aload_3
        18: athrow
        19: return
      Exception table:
         from    to  target type
             4    11    14   any
            14    17    14   any
      LineNumberTable:
        line 10: 0
        line 11: 4
        line 12: 9
        line 13: 19
~~~

当声明 synchronized 代码块时，synchronized 经过 Javac 编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令。这两种指令均会消耗操作数栈上的一个 reference 类型的元素（也就是 synchronized 关键字括号里的引用），作为所要加锁解锁的锁对象。

编译后的字节码包含一个 monitorenter 指令以及多个 monitorexit 指令。这是因为 JVM 需要确保所获得的锁在正常执行路径，以及异常执行路径上都能够被解锁。

对于 monitorenter 和 monitorexit 指令的作用，我们可以抽象地理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。

当执行 monitorenter 时，如果目标锁对象的计数器为 0，那么说明它没有被其他线程所持有。在这个情况下，JVM 会将该锁对象的持有线程设置为当前线程，并且将其计数器加 1。

在目标锁对象的计数器不为 0 的情况下，如果锁对象的持有线程是当前线程，那么 JVM 可以将其计数器加 1（synchronized为可重入锁），否则需要等待，直至持有线程释放该锁。

当执行 monitorexit 时，JVM 则需将锁对象的计数器减 1。当计数器减为 0 时，那便代表该锁已经被释放掉了。

### 同步方法

~~~java
public synchronized void fooSync(Object lock) {
    lock.hashCode();
}
//---将上面的Java代码通过 javap 命令编译为下面的字节码---
  public synchronized void fooSync(java.lang.Object);
    descriptor: (Ljava/lang/Object;)V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=1, locals=2, args_size=2
         0: aload_1
         1: invokevirtual #2                  // Method java/lang/Object.hashCode:()I
         4: pop
         5: return
      LineNumberTable:
        line 15: 0
        line 16: 5
~~~

如上述代码所示，当用 synchronized 标记方法时，这里的同步是隐式的，无须通过字节码指令来控制。JVM 可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否被声明为同步方法。

当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。

## 锁优化

JDK 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 JDK 1.6 中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。

### 重量级锁

重量级锁是 JVM 中最为基础的锁实现。在这种状态下，JVM 会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。Java 线程的阻塞以及唤醒，依赖于操作系统的互斥量（mutex） 实现，这些操作需要从操作系统的用户态切换至内核态，其开销非常之大。

为了尽量避免线程阻塞、唤醒操作，JVM 会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。这就是所谓的自旋锁。

如果在轮询时，锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。但是，自旋等待不能代替阻塞。自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，如果锁被占用的时间很长，自旋的线程会白白消耗处理器资源，造成性能的浪费。

因此自旋等待的时间会有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就会使用传统的方式去挂起线程。自旋次数的默认值是 10 次（JVM 对应参数`-XX：PreBlockSpin`）。

由于自旋次数对整个 JVM 中所有的锁来说都是相同的，在 JDK 6中对自旋锁进行了优化，引入了自适应的自旋。自适应意味着自旋时间（循环次数）不再是固定的了，而是根据以往自旋等待时是否能够获得锁，来动态调整自旋的时间。比如，在同一个锁对象上，自旋等待刚刚成功获得过锁，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程。

但是，自旋状态还带来另外一个副作用，那便是不公平的锁机制。处于阻塞状态的线程，并没有办法立刻竞争被释放的锁。处于自旋状态的线程，则很有可能优先获得这把锁。

### 轻量级锁

多个线程在不同的时间段请求同一把锁，不存在锁竞争的情况。针对这种情形，JVM 采用了轻量级锁，来避免重量级锁的阻塞以及唤醒。

#### 轻量级锁加锁

线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，官方称为 Displaced Mark Word。

然后，JVM 会尝试用 CAS（compare-and-swap）操作将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，并且对象 Mark Word 的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。

如果失败，那么有两种可能：

1. 该线程重复获取同一把锁。此时，JVM会将锁记录清零，以代表该锁被重复获取。
2. 其他线程持有该锁。此时，JVM 会将这把锁膨胀为重量级锁，锁标志的状态值变为“10”，此时 Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。

#### 轻量级锁解锁

当进行解锁操作时，如果当前锁记录（你可以将一个线程的所有锁记录想象成一个栈结构，每次加锁压入一条锁记录，解锁弹出一条锁记录，当前锁记录指的便是栈顶的锁记录）的值为 0，则代表重复进入同一把锁，直接返回即可。

否则，JVM 使用 CAS 操作将线程中复制的 Displaced Mark Word替换回对象当前的 Mark Word 。如果成功，该线程已经成功释放这把锁。如果替换失败，则意味着这把锁已经被膨胀为重量级锁。此时，JVM 会进入重量级锁的释放过程，唤醒因竞争该锁而被阻塞了的线程。

因为自旋会消耗 CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过 CAS 操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下， 轻量级锁反而会比传统的重量级锁更慢。

### 偏向锁

HotSpot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。它的目的是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不去做。

#### 实现原理

偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

具体来说，当锁对象第一次被线程获取的时候， JVM 会通过 CAS 操作，将当前线程ID 记录在锁对象的的 Mark Word 之中，并且将 Mark Word 的最后三位设置为 101（是否偏向锁 + 锁标志位）。

在接下来的运行过程中，每当有线程请求这把锁，JVM 只需判断锁对象 Mark Word 中：最后三位是否为 101，是否包含当前线程的ID，以及 epoch 值是否和锁对象的类的 epoch 值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回。

如果不满足，就代表有另一个线程来竞争这个偏向锁。这个时候通过 CAS 操作竞争锁，分两种情况：

- 成功：表示之前的线程不存在了， 将 Mark Word 中线程ID设置为当前线程ID，锁不会升级，仍然为偏向锁
- 失败： 表示之前的线程仍然存在，有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。

偏向锁针对的场景就是从始至终只有一个线程请求某一把锁，一旦出现竞争就不再使用偏向锁。

#### 偏向锁的撤销

偏向锁使用了一种等到竞争出现才释放锁的机制，所以一旦有其他线程尝试竞争偏向锁时，偏向模式就马上宣告结束。偏向锁的撤销，需要持有偏向锁的线程到达全局安全点（该状态下所有线程都是暂停的）。

具体的做法是在每个类中维护一个 epoch 值，可以理解为第几代偏向锁。当设置偏向锁时，JVM 需要将该 epoch 值复制到锁对象的Mark Word 中。在宣布某个类的偏向锁失效时（撤销达到20次），JVM 则将该类的 epoch 值加 1，表示之前那一代的偏向锁已经失效。而新设置的偏向锁则需要复制新的 epoch 值。

为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，JVM 需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们 Mark Word 中的 epoch 值加 1。该操作需要所有线程处于安全点状态。

如果某一类锁对象的总撤销数超过了一个阈值（对应 JVM 参数 `-XX:BiasedLockingBulkRebiasThreshold`，默认为 20），那么 JVM 会宣布这个类的偏向锁失效。

如果总撤销数超过另一个阈值（对应 JVM 参数 `-XX:BiasedLockingBulkRevokeThreshold`，默认值为 40），那么 JVM 会认为这个类已经不再适合偏向锁。此时，JVM 会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。

#### 偏向锁的关闭

在 Java 6、7 里偏向锁是默认启用的，但是它在应用程序启动几秒钟之后才激活，可以关闭延迟（对应JVM 参数 `-XX:BiasedLockingStartupDelay=0`。

如果应用程序里所有的锁通常情况下处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，可以关闭偏向锁（对应 JVM 参数`-XX:- UseBiasedLocking=false`），那么程序默认会进入轻量级锁状态。

### 锁的优缺点对比

![image-20210723214450185](assets/20210723214457.png)
