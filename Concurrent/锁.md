# 锁

## Java锁简介

JUC包提供了种类丰富的锁，每种锁特性各不相同。

- **ReentrantLock重入锁：**它具有与使用 synchronized 相同的一些基本行为和语义，但是它的API功能更强大，重入锁相当于synchronized 的增强版，具有synchronized很多所没有的功能。**它是一种独享锁（互斥锁），可以是公平锁，也可以是非公平的锁。**
- **ReentrantReadWriteLock读写锁：**它维护了一对锁，ReadLock读锁和WriteLock写锁。**读写锁适合读多写少的场景**。**`基本原则：读锁可以被多个线程同时持有进行访问，而写锁只能被一个线程持有`**。可以这么理解：**读写锁是个混合体，它既是一个共享锁，也是一个独享锁。**
- **StampedLock重入读写锁：**JDK1.8引入的锁类型，是对读写锁ReentrantReadWriteLock的增强版。

## 锁分类

### 按上锁方式划分

- **隐式锁：**synchronized，不需要显示加锁和解锁
- **显式锁：**JUC包中提供的锁，需要显示加锁和解锁

### 按特性划分

#### 悲观锁/乐观锁

**`按照线程在使用共享资源时，要不要锁住同步资源`**，划分为悲观锁和乐观锁。

- **悲观锁：**比较悲观，总是假设最坏的情况，对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在**获取数据的时候会先加锁，确保数据不会被别的线程修改**。**实现：**JUC锁，synchronized
- **乐观锁：**比较乐观，总是假设最好的情况，对于同一个数据的并发操作，**乐观锁认为自己在使用数据时不会有别的线程修改数据，所以在获取数据的时候不会添加锁**。只有在更新数据的时候才会去判断有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入；如果数据已经被其他线程更新，则会根据不同的情况执行不同的操作（例如：报错或自动重试）。**实现：**CAS，关系型数据库的版本号机制

**开销对比：**

- 悲观锁的原始开销要高于乐观锁，特点是一劳永逸，临界区持锁的时间就算越来越差，也不会对互斥锁的开销造成影响
- 乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多

**使用场景：**

- 适合并发写入多的情况，适用于临界区持锁时间比较长的情况，可以避免大量的无用自选等情况，例如：临界区有IO操作、临界区代码复杂或循环量大等
- 适合并发写入少、大部分是读取的场景

#### 重入锁/不可重入锁

**`按照同一个线程是否可以重复获取同一把锁`**,划分为重入锁和不可重入锁。

- **重入锁：**一个线程可以重复获取同一把锁，不会因为之前已经获取了该锁未释放而被阻塞。在获得一个锁之后未释放锁之前，再次获得同一把锁时，只会增加获得锁的次数，当释放锁时，会同时减少锁定次数。**可重入锁的一个优点是可一定程度避免死锁**。**实现：**ReentrantLock、synchronized
- **不可重入锁：**不可重入锁，与可重入锁相反，线程获取锁之后不可重复获取锁，重复获取会发生死锁

#### 公平锁/非公平锁

**`按照多个线程竞争同一锁时需不需要排队，能不能插队`**，划分为公平锁和非公平锁。

- **公平锁：**多个线程按照申请锁的顺序来获得锁，**实现：**new ReentrantLock(true)多个线程按照申请锁的顺序获取锁
- **非公平锁：**多个线程获取锁的顺序不是按照申请锁的顺序(可以插队)。**实现：**new ReentrantLock(false)、 synchronized

**非公平锁**更快，吞吐量大，可以避免线程唤醒带来的空档期，但是有可能产生线程饥饿，也就是某些线程在长时间内始终得不到执行。

**特例：**tryLock()方法，不遵守设定的公平原则，当有线程执行tyrLock()的时候，一旦有线程释放了锁，那么这个正在tryLock()的线程就能获取锁，即使在它之前已经有其他线程在等待队列中。

#### 独享锁/共享锁

**`按照多个线程能不能同时共享同一个锁`**，锁被划分为独享锁和共享锁。

- **独享锁（写锁）：**独享锁也叫排他锁，是指同一个锁同时只能被一个线程所持有。如果线程A对获得了锁S后，则其他线程只能阻塞等待线程A释放锁S后，才能获得S。**实现：**synchronized，ReentrantLock， ReentrantReadWriteLock 的WriteLock写锁
- **共享锁（读锁）：**同一个锁可被多个线程同时持有。如果线程A对获得了共享锁S后，则其他线程无需等待可以获得共享锁S。**实现：**ReentrantReadWriteLock的ReadLock读锁

ReentrantReadWriteLock，其中读锁是共享锁，写锁是独享锁。

**读写锁规则**

- 多个线程申请读锁，都可以申请得到
- 如果一个线程已经占用了读锁，此时其他线程申请写锁，则申请写锁的线程会一直等待释放读锁
- 如果一个线程已经占用了写锁，此时其他线程申请写锁或读锁，则申请的线程会一直等待释放写锁
- 总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现（要么多读，要么一写）

**读锁插队策略**

- **公平锁：**不允许插队
- **非公平锁：**写锁可以随时插队（尝试获取锁，获取不到进入队列排队），读锁仅在等待队列头结点的线程不是获取写锁的时候可以插队

### 其他

#### 自旋锁

获取锁失败时，线程不会阻塞而是循环尝试获得锁，直至获得锁成功。**实现：**CAS、轻量级锁

#### 分段锁

容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率。**实现：**ConcurrentHashMap
ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

#### 无锁/偏向锁/轻量级锁/重量级锁

**这四个锁是synchronized独有的四种状态**，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。它们是JVM为了提高synchronized锁的获取与释放效率而做的优化，**四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级**。

## Synchronized和JUC的锁对比

synchronized 同步锁提供了一种排他式的同步机制，当多个线程竞争锁资源时，同时只能有一个线程持有锁，当一个线程获取了锁，其他线程就会被阻塞只有等到占有锁的线程释放锁后，才能重新进行锁竞争。

**使用synchronized同步锁，线程会三种情况下释放锁：**

1. 线程执行完了同步代码块/方法，释放锁；
2. 线程执行时发生异常，此时JVM会让线程自动释放锁；
3. 在同步代码块/方法中，锁对象执行了wait方法，线程释放锁

### Synchronize的缺陷

#### 一、无法控制阻塞时长，阻塞不可中断

使用synchronized同步锁，假如占有锁的线程被长时间阻塞（IO阻塞，sleep方法，join方法等），由于线程在阻塞时没有释放锁，如果其他线程尝试获取锁，就会被阻塞只能一直等待下去，甚至会发生死锁，这样就会造成大量线程的堆积，严重的影响服务器的性能。

**JUC的锁可以解决这两个缺陷：**

- tryLock(long time, TimeUnit unit)
- lockInterruptibly()

#### 二、读多写少的场景中，多个读线程同时操作共享资源时不需要加锁

读多写少的场景中，当多个读线程同时操作共享资源时，读操作不会对共享资源进行修改，所以读线程和读线程是不需要同步的。如果这时采用synchronized关键字，就会导致所有线程都只能同步进行，只能有一个读线程可以进行读操作，其他读线程只能等待锁的释放而无法进行读操作。

在上述场景中，我们需要实现一种机制，**当多个线程都都只是进行读操作时，使得线程可以同时进行读操作（共享锁）**。synchronized同步锁，不支持这种操作。**JUC的ReentrantReadWriteLock锁可以解决以上问题**。



